(function(){"use strict";var j=Object.defineProperty,H=(u,e,t)=>e in u?j(u,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):u[e]=t,S=(u,e,t)=>H(u,typeof e!="symbol"?e+"":e,t);class E{constructor(){S(this,"strToUniqueId",new Map),S(this,"uniqueIdToStr",new Map),S(this,"currentUniqueId",0)}id(e){if(!e||e.trim()==="")throw new Error("Cannot store empty or whitespace-only strings");const t=this.strToUniqueId.get(e);if(t!==void 0)return t;const s=this.currentUniqueId++;return this.strToUniqueId.set(e,s),this.uniqueIdToStr.set(s,e),s}str(e){const t=this.uniqueIdToStr.get(e);if(!t)throw new Error("pub: invalid id "+e);return t}has(e){return this.strToUniqueId.has(e)}*[Symbol.iterator](){yield*this.uniqueIdToStr.entries()}remove(e){const t=this.uniqueIdToStr.get(e);t!==void 0&&(this.uniqueIdToStr.delete(e),this.strToUniqueId.delete(t))}}const q=/^[0-9a-fA-F]{64}$/,V=2;function _(u,e,t,s,r){const o=new Set,i=new Map,n=new Map,{followedByUser:l,mutedByUser:w}=u.getInternalData(),g=u.usersByFollowDistance,h=Array.from(g.keys()).sort((f,d)=>f-d),a=s!==void 0?h.filter(f=>f<=s):h,c=[];for(const f of a){const d=g.get(f);if(d)for(const m of d){let U=0;const F=l.get(m);if(F)for(const k of F)(!r||U<r)&&(c.push({owner:m,target:k,isFollow:!0,distance:f}),U++);const C=w.get(m);if(C)for(const k of C)(!r||U<r)&&(c.push({owner:m,target:k,isFollow:!1,distance:f}),U++)}}let y=0;const{str:B}=u.getInternalData();for(const f of c){if(t&&y>=t)break;try{B(f.owner),B(f.target)}catch{console.warn(`Skipping edge with invalid ID: owner=${f.owner}, target=${f.target}`);continue}if(e){const m=!o.has(f.owner),U=!o.has(f.target),F=(m?1:0)+(U?1:0);if(o.size+F>e)break}o.add(f.owner),o.add(f.target),y++;const d=f.isFollow?i:n;d.set(f.owner,(d.get(f.owner)??0)+1)}const v=Array.from(i.keys()),p=Array.from(n.keys());return{usedIds:o,followEdgeCount:i,muteEdgeCount:n,followOwners:v,muteOwners:p}}function G(u){return u.getInternalData()}function J(u){if(!/^[0-9a-fA-F]+$/.test(u))throw new Error(`Invalid hex string: ${u}`);if(u.length%2!==0)throw new Error(`Hex string must have even length: ${u}`);const e=new Uint8Array(u.length/2);for(let t=0;t<u.length;t+=2)e[t/2]=parseInt(u.substr(t,2),16);return e}function K(u){return Array.from(u).map(e=>e.toString(16).padStart(2,"0")).join("")}function D(u,e){let t=0,s=0,r=0;for(let o=e;o<u.length;o++){const i=u[o];if(t|=(i&127)<<s,r++,(i&128)===0)break;s+=7}return{value:t,bytesRead:r}}async function*$(u,e,t,s,r){const o=G(u);let i,n,l,w,g;if(e!==void 0||t!==void 0||s!==void 0||r!==void 0){const d=_(u,e,t,s,r);i=d.usedIds,n=d.followEdgeCount,l=d.muteEdgeCount,w=d.followOwners,g=d.muteOwners}else{i=new Set,n=new Map,l=new Map;for(const[d,m]of o.followedByUser.entries()){i.add(d),n.set(d,m.size);for(const U of m)i.add(U)}for(const[d,m]of o.mutedByUser.entries()){i.add(d),l.set(d,m.size);for(const U of m)i.add(U)}w=Array.from(n.keys()),g=Array.from(l.keys())}const h=16*1024;let a=new Uint8Array(h),c=0;const y=[],B=()=>{c!==0&&(y.push(a.subarray(0,c)),a=new Uint8Array(h),c=0)},v=d=>{c>=a.length&&B(),a[c++]=d},p=d=>{let m=0;for(;m<d.length;){const U=a.length-c;if(U===0){B();continue}const F=Math.min(U,d.length-m);a.set(d.subarray(m,m+F),c),c+=F,m+=F}},f=d=>{let m=d>>>0;for(;m>=128;)v(m&127|128),m>>>=7;v(m&127)};f(V),f(i.size);for(const d of i)p(J(o.ids.str(d))),f(d);f(w.length);for(const d of w){const m=o.followListCreatedAt.get(d)??0,U=n.get(d);f(d),f(m),f(U);let F=0;const C=o.followedByUser.get(d)||new Set;for(const k of C){if(F>=U)break;f(k),F++}}f(g.length);for(const d of g){const m=o.muteListCreatedAt.get(d)??0,U=l.get(d);f(d),f(m),f(U);let F=0;const C=o.mutedByUser.get(d)||new Set;for(const k of C){if(F>=U)break;f(k),F++}}B();for(const d of y)yield d}async function Q(u,e,t,s,r){const o=[];let i=0;for await(const w of $(u,e,t,s,r))o.push(w),i+=w.length;const n=new Uint8Array(i);let l=0;for(const w of o)n.set(w,l),l+=w.length;return n}async function P(u,e){var t;let s=0;const r=D(e,s);s+=r.bytesRead;const o=D(e,s);s+=o.bytesRead;const i=[];for(let c=0;c<o.value;c++){const y=e.slice(s,s+32);s+=32;const B=K(y),v=D(e,s);s+=v.bytesRead,i.push([B,v.value])}const n=D(e,s);s+=n.bytesRead;const l=[];for(let c=0;c<n.value;c++){const y=D(e,s);s+=y.bytesRead;const B=D(e,s);s+=B.bytesRead;const v=D(e,s);s+=v.bytesRead;const p=[];for(let f=0;f<v.value;f++){const d=D(e,s);s+=d.bytesRead,p.push(d.value)}l.push([y.value,p,B.value])}const w=D(e,s);s+=w.bytesRead;const g=[];for(let c=0;c<w.value;c++){const y=D(e,s);s+=y.bytesRead;const B=D(e,s);s+=B.bytesRead;const v=D(e,s);s+=v.bytesRead;const p=[];for(let f=0;f<v.value;f++){const d=D(e,s);s+=d.bytesRead,p.push(d.value)}g.push([y.value,p,B.value])}const h=new I(u),a=h;a.ids.uniqueIdToStr.clear(),a.ids.strToUniqueId.clear(),a.ids.currentUniqueId=0;for(const[c,y]of i)a.ids.uniqueIdToStr.set(y,c),a.ids.strToUniqueId.set(c,y),a.ids.currentUniqueId=Math.max(a.ids.currentUniqueId,y+1);if(a.ids.strToUniqueId.has(u))a.root=a.ids.strToUniqueId.get(u);else{const c=a.ids.id(u);a.root=c}a.followDistanceByUser.clear(),a.usersByFollowDistance.clear(),a.followDistanceByUser.set(a.root,0),a.usersByFollowDistance.set(0,new Set([a.root]));for(const[c,y,B]of l){for(const v of y)a.privateAddFollower(v,c);a.followListCreatedAt.set(c,B??0)}for(const[c,y,B]of g){a.mutedByUser.set(c,new Set(y));for(const v of y)a.userMutedBy.has(v)||a.userMutedBy.set(v,new Set),(t=a.userMutedBy.get(v))==null||t.add(c);a.muteListCreatedAt.set(c,B??0)}return h}async function W(u,e){const t=e.getReader(),s=[];let r=0;try{for(;;){const{done:n,value:l}=await t.read();if(n)break;s.push(l),r+=l.length}}finally{t.releaseLock()}const o=new Uint8Array(r);let i=0;for(const n of s)o.set(n,i),i+=n.length;return await P(u,o)}class M{static removeMutedNotFollowedUsers(e,t=1e4,s=()=>{}){console.time("removeMutedNotFollowedUsers");let r="";return new Promise(o=>{const{followedByUser:i,userMutedBy:n}=e.getInternalData(),l=new Set,w=Array.from(i.entries());let g=0;s("Building follower counts",0,0),console.log("Building follower index..."),console.time("Building follower index"),r="building";const h=()=>{const p=Math.min(g+t,w.length);for(let f=g;f<p;f++){const[,d]=w[f];for(const m of d)l.add(m)}g=p,g<w.length?setTimeout(h,0):B()},a=[],c=Array.from(n.entries());let y=0;const B=()=>{const p=Math.min(y+t,c.length);for(let f=y;f<p;f++){const[d,m]=c[f];m.size>0&&!l.has(d)&&a.push(d)}y=p,(y%(t*10)===0||y===p)&&(r!=="scanning"&&(console.timeEnd("Building follower index"),console.time("Scanning muted users"),r="scanning"),console.log(`Scanned ${y.toLocaleString()} muted users, found ${a.length.toLocaleString()} to remove`),s("Scanning muted users",y,a.length)),y<c.length?setTimeout(B,0):(console.timeEnd("Scanning muted users"),console.time("Removing users"),r="removing",s("Removing users",y,a.length),v())},v=()=>{if(a.length===0){console.timeEnd("Removing users"),console.log("✅ Cleanup complete: removed 0 muted users with zero followers"),s("Cleanup complete",c.length,0),console.timeEnd("removeMutedNotFollowedUsers"),o(0);return}console.log(`Batch removing ${a.length.toLocaleString()} users...`),M.batchRemoveUsers(e,a),console.timeEnd("Removing users"),console.log(`✅ Cleanup complete: removed ${a.length.toLocaleString()} muted users with zero followers`),s("Cleanup complete",c.length,a.length),console.timeEnd("removeMutedNotFollowedUsers"),o(a.length)};setTimeout(h,0)})}static batchRemoveUsers(e,t){var s;const{ids:r}=e.getInternalData(),o=e,i=new Map;for(const n of t)i.set(n,{followedUsers:o.followedByUser.get(n)||new Set,mutedUsers:o.mutedByUser.get(n)||new Set,userMuters:o.userMutedBy.get(n)||new Set,followDistance:o.followDistanceByUser.get(n)});for(const n of t){const l=i.get(n);r.remove(n),l.followDistance!==void 0&&((s=o.usersByFollowDistance.get(l.followDistance))==null||s.delete(n)),o.followDistanceByUser.delete(n),o.followedByUser.delete(n),o.followersByUser.delete(n),o.followListCreatedAt.delete(n),o.mutedByUser.delete(n),o.userMutedBy.delete(n),o.muteListCreatedAt.delete(n)}for(const[,n]of o.followedByUser)for(const l of t)n.delete(l);for(const[,n]of o.followersByUser)for(const l of t)n.delete(l);for(const n of t){const l=i.get(n);for(const w of l.userMuters){const g=o.mutedByUser.get(w);g&&g.delete(n)}for(const w of l.mutedUsers){const g=o.userMutedBy.get(w);g&&g.delete(n)}}}static removeUserById(e,t){M.batchRemoveUsers(e,[t])}static stats(e,t){const s={},r=e,o=r.id(t),i=M.getFollowersSet(e,o);for(const n of i){const l=r.followDistanceByUser.get(n);l!==void 0&&(s[l]||(s[l]={followers:0,muters:0}),s[l].followers++)}for(const n of r.userMutedBy.get(o)||[]){const l=r.followDistanceByUser.get(n);l!==void 0&&(s[l]||(s[l]={followers:0,muters:0}),s[l].muters++)}return s}static getFollowersSet(e,t){const{followersByUser:s}=e.getInternalData();return s.get(t)||new Set}static hasFollowers(e,t){const s=e.id(t),{followersByUser:r}=e.getInternalData(),o=r.get(s);return o?o.size>0:!1}static isOvermuted(e,t,s=1){if(t===e.getRoot())return!1;const r=e,o=r.id(t),{followersByUser:i,userMutedBy:n}=e.getInternalData(),l=n.get(o);if(!l||l.size===0)return!1;const w=new Map,g=i.get(o);if(g)for(const a of g){const c=r.followDistanceByUser.get(a);c!==void 0&&(w.has(c)||w.set(c,{followers:0,muters:0}),w.get(c).followers++)}for(const a of l){const c=r.followDistanceByUser.get(a);c!==void 0&&(w.has(c)||w.set(c,{followers:0,muters:0}),w.get(c).muters++)}const h=Array.from(w.keys()).sort((a,c)=>a-c);for(const a of h){const{followers:c,muters:y}=w.get(a);if(c+y>0)return y*s>c}return!1}static async pruneOvermutedUsers(e,t=1,s=()=>{}){console.time("pruneOvermutedUsers");let r=0;const o=e;let i=1,n=!0;for(;n;){const l=o.usersByFollowDistance.get(i);if(!l||l.size===0){n=!1;continue}console.log(`Processing distance ${i} (${l.size.toLocaleString()} users)...`);const w=[];for(const g of l){const h=o.str(g);M.isOvermuted(e,h,t)&&w.push(g)}if(s(i,l.size,w.length),w.length>0&&(console.log(`  Removing ${w.length.toLocaleString()} overmuted users at distance ${i}`),M.batchRemoveUsers(e,w),r+=w.length),i++,i>20){console.warn("Stopping pruning at distance 20 to prevent infinite loop");break}}return console.timeEnd("pruneOvermutedUsers"),console.log(`✅ Pruning complete: removed ${r.toLocaleString()} overmuted users total`),e.recalculateFollowDistances(),r}}class I{constructor(e){S(this,"root"),S(this,"recalculatingPromise",null),S(this,"followDistanceByUser",new Map),S(this,"usersByFollowDistance",new Map),S(this,"followedByUser",new Map),S(this,"followersByUser",new Map),S(this,"followListCreatedAt",new Map),S(this,"mutedByUser",new Map),S(this,"userMutedBy",new Map),S(this,"muteListCreatedAt",new Map),S(this,"ids",new E),S(this,"isRecalculating",!1),this.ids=new E,this.root=this.id(e),this.followDistanceByUser.set(this.root,0),this.usersByFollowDistance.set(0,new Set([this.root]))}id(e){return this.ids.id(e)}str(e){return this.ids.str(e)}getRoot(){return this.str(this.root)}getInternalData(){return{followedByUser:this.followedByUser,followersByUser:this.followersByUser,mutedByUser:this.mutedByUser,userMutedBy:this.userMutedBy,followListCreatedAt:this.followListCreatedAt,muteListCreatedAt:this.muteListCreatedAt,ids:this.ids,str:e=>this.str(e)}}setRoot(e){const t=this.id(e);return t===this.root?Promise.resolve():(this.root=t,this.isRecalculating&&this.recalculatingPromise?this.recalculatingPromise.then(()=>this.recalculateFollowDistances()):this.recalculateFollowDistances())}recalculateFollowDistances(e=1e3,t=1e5,s=console.log){return this.isRecalculating?this.recalculatingPromise.then(()=>this.recalculateFollowDistances(e,t,s)):(this.isRecalculating=!0,this.recalculatingPromise=new Promise(r=>{var o;const i=this.root,n=this.followDistanceByUser,l=this.usersByFollowDistance,w=this.followedByUser;n.clear(),l.clear(),n.set(i,0),l.set(0,new Set([i]));const g=[i];let h=0,a=0;const c=((o=performance.now)==null?void 0:o.call(performance))??Date.now();s(`recalculateFollowDistances: start (batchSize=${e})`);const y=()=>{var B;const v=Math.min(h+e,g.length);for(;h<v;h++){const p=g[h],f=n.get(p),d=w.get(p);if(!d)continue;const m=f+1;for(const U of d)if(!n.has(U)){n.set(U,m);let F=l.get(m);F||(F=new Set,l.set(m,F)),F.add(U),g.push(U)}}if(a=h,a>0&&a%t<e&&s(`recalculateFollowDistances: ${a} processed, ${g.length-h} remaining`),h<g.length)setTimeout(y,0);else{const p=(((B=performance.now)==null?void 0:B.call(performance))??Date.now())-c;s(`recalculateFollowDistances: done (${a} users) in ${p.toFixed(1)}ms`),this.isRecalculating=!1,this.recalculatingPromise=null,r()}};y()}),this.recalculatingPromise)}handleEvent(e,t=!1,s=1){const r=(Array.isArray(e)?e:[e]).filter(o=>[3,1e4].includes(o.kind));for(const o of r){const i=o.created_at;if(i>Math.floor(Date.now()/1e3)+600){console.debug("event.created_at more than 10 minutes in the future",o);continue}const n=this.id(o.pubkey);!t&&!this.followDistanceByUser.has(n)||M.isOvermuted(this,o.pubkey,s)||(o.kind===3?this.handleFollowList(o,n,i):o.kind===1e4&&this.handleMuteList(o,n,i))}}handleFollowList(e,t,s){const r=this.followListCreatedAt.get(t);if(r&&s<=r)return;this.followListCreatedAt.set(t,s);const o=new Set;for(const n of e.tags)if(n[0]==="p"){if(!q.test(n[1]))continue;const l=this.id(n[1]);l!==t&&o.add(l)}const i=this.followedByUser.get(t)||new Set;for(const n of i)o.has(n)||this.privateRemoveFollower(n,t);for(const n of o)this.privateAddFollower(n,t)}handleMuteList(e,t,s){var r,o,i,n;const l=this.muteListCreatedAt.get(t);if(l&&s<=l)return;this.muteListCreatedAt.set(t,s);const w=new Set;for(const h of e.tags)if(h[0]==="p"){if(!q.test(h[1]))continue;const a=this.id(h[1]);a!==t&&w.add(a)}const g=this.mutedByUser.get(t)||new Set;for(const h of g)w.has(h)||((r=this.mutedByUser.get(t))==null||r.delete(h),(o=this.userMutedBy.get(h))==null||o.delete(t));for(const h of w)this.mutedByUser.has(t)||this.mutedByUser.set(t,new Set),(i=this.mutedByUser.get(t))==null||i.add(h),this.userMutedBy.has(h)||this.userMutedBy.set(h,new Set),(n=this.userMutedBy.get(h))==null||n.add(t)}isFollowing(e,t){var s;const r=this.id(t),o=this.id(e);return!!((s=this.followedByUser.get(o))!=null&&s.has(r))}getFollowDistance(e){const t=this.followDistanceByUser.get(this.id(e));return t===void 0?1e3:t}addUserByFollowDistance(e,t){var s,r;this.usersByFollowDistance.has(e)||this.usersByFollowDistance.set(e,new Set),(s=this.usersByFollowDistance.get(e))==null||s.add(t);for(const o of this.usersByFollowDistance.keys())o>e&&((r=this.usersByFollowDistance.get(o))==null||r.delete(t))}privateAddFollower(e,t){if(typeof e!="number"||typeof t!="number")throw new Error("Invalid user id");if(this.followedByUser.has(t)||this.followedByUser.set(t,new Set),this.followedByUser.get(t).add(e),this.followersByUser.has(e)||this.followersByUser.set(e,new Set),this.followersByUser.get(e).add(t),e!==this.root){let s;if(t===this.root)s=1,this.addUserByFollowDistance(s,e),this.followDistanceByUser.set(e,s);else{const r=this.followDistanceByUser.get(e),o=this.followDistanceByUser.get(t);s=o&&o+1,(r===void 0||s&&s<r)&&(this.followDistanceByUser.set(e,s),this.addUserByFollowDistance(s,e))}}}addFollower(e,t){this.privateAddFollower(this.id(t),this.id(e))}removeFollower(e,t){this.privateRemoveFollower(this.id(t),this.id(e))}privateRemoveFollower(e,t){var s,r;if((s=this.followedByUser.get(t))==null||s.delete(e),(r=this.followersByUser.get(e))==null||r.delete(t),e===this.root)return;let o=1/0;for(const i of this.getFollowersSet(e)){const n=this.followDistanceByUser.get(i);n!==void 0&&n+1<o&&(o=n+1)}o===1/0?this.followDistanceByUser.delete(e):this.followDistanceByUser.set(e,o)}followerCount(e){const t=this.id(e);return this.getFollowersSet(t).size}followedByFriendsCount(e){var t;let s=0;const r=this.id(e);for(const o of this.getFollowersSet(r))(t=this.followedByUser.get(this.root))!=null&&t.has(o)&&s++;return s}mutedByFriendsCount(e){var t;let s=0;const r=this.id(e);for(const o of this.userMutedBy.get(r)??[])(t=this.followedByUser.get(this.root))!=null&&t.has(o)&&s++;return s}size(){var e;let t=0,s=0;const r={};for(const o of this.followedByUser.values())t+=o.size;for(const o of this.mutedByUser.values())s+=o.size;for(const[o,i]of this.usersByFollowDistance.entries())r[o]=i.size;return{users:this.followDistanceByUser.size||((e=this.ids.uniqueIdToStr)==null?void 0:e.size)||0,follows:t,mutes:s,sizeByDistance:r}}followedByFriends(e){var t;const s=this.id(e),r=new Set;for(const o of this.getFollowersSet(s))(t=this.followedByUser.get(this.root))!=null&&t.has(o)&&r.add(this.str(o));return r}getFollowedByUser(e,t=!1){const s=this.id(e),r=new Set;for(const o of this.followedByUser.get(s)||[])r.add(this.str(o));return t&&r.add(e),r}getFollowersByUser(e){const t=this.id(e),s=new Set;for(const r of this.getFollowersSet(t))s.add(this.str(r));return s}getUsersByFollowDistance(e){const t=this.usersByFollowDistance.get(e)||new Set,s=new Set;for(const r of t)s.add(this.str(r));return s}getFollowListCreatedAt(e){return this.followListCreatedAt.get(this.id(e))}merge(e){return new Promise(t=>{console.log("size before merge",this.size()),console.time("merge graph");const s=Array.from(e);let r=0;const o=()=>{if(r>=s.length){this.recalculateFollowDistances().then(()=>{console.timeEnd("merge graph"),console.log("size after merge",this.size()),t()});return}const i=s[r];this.mergeUserLists(i,this.followListCreatedAt,e.followListCreatedAt,this.followedByUser,e.followedByUser),this.mergeUserLists(i,this.muteListCreatedAt,e.muteListCreatedAt,this.mutedByUser,e.mutedByUser),r++,setTimeout(o,0)};setTimeout(o,0)})}mergeUserLists(e,t,s,r,o){const i=this.id(e),n=t.get(i),l=s.get(i);if(!n||l&&n<l){const w=o.get(i)||new Set,g=r.get(i)||new Set;for(const h of w)g.has(h)||(r.has(i)||r.set(i,new Set),r.get(i).add(h));for(const h of g)w.has(h)||r.get(i).delete(h);t.set(i,l??0)}}*userIterator(e){const t=Array.from(this.usersByFollowDistance.keys()).sort((s,r)=>s-r);for(const s of t){if(e!==void 0&&s>e)break;const r=this.usersByFollowDistance.get(s)||new Set;for(const o of r)yield this.str(o)}}[Symbol.iterator](){return this.userIterator()}getMutedByUser(e){const t=this.id(e),s=new Set;for(const r of this.mutedByUser.get(t)||[])s.add(this.str(r));return s}getUserMutedBy(e){const t=this.id(e),s=new Set;for(const r of this.userMutedBy.get(t)||[])s.add(this.str(r));return s}stats(e){return M.stats(this,e)}removeMutedNotFollowedUsers(e=1e4,t=()=>{}){return M.removeMutedNotFollowedUsers(this,e,t)}toBinaryChunks(e,t,s,r){return $(this,e,t,s,r)}toBinary(e,t,s,r){return Q(this,e,t,s,r)}static fromBinary(e,t){return P(e,t)}static fromBinaryStream(e,t){return W(e,t)}getFollowersSet(e){return M.getFollowersSet(this,e)}}const O="4523be58d395b1b196a9b8c82b038b6895cb02b683d0c253a955068dba1facd0",X="hashtree-social-graph-worker",R="graph",Y=15e3;let b=new I(O),L=null,T=null,z=0;function A(u){self.postMessage(u)}function x(){z++,A({type:"versionUpdate",version:z})}function N(){return new Promise((u,e)=>{const t=indexedDB.open(X,1);t.onerror=()=>e(t.error),t.onsuccess=()=>u(t.result),t.onupgradeneeded=()=>{const s=t.result;s.objectStoreNames.contains(R)||s.createObjectStore(R)}})}async function Z(u){try{return L||(L=await N()),new Promise(e=>{const r=L.transaction(R,"readonly").objectStore(R).get("main");r.onsuccess=async()=>{var o;if((o=r.result)!=null&&o.data)try{const i=await I.fromBinary(u,r.result.data);e(i)}catch{e(null)}else e(null)},r.onerror=()=>e(null)})}catch{return null}}async function ee(){try{L||(L=await N());const u=await b.toBinary();return new Promise(e=>{const t=L.transaction(R,"readwrite");t.objectStore(R).put({data:u,updatedAt:Date.now()},"main"),t.oncomplete=()=>e(),t.onerror=()=>e()})}catch(u){console.error("[socialGraph.worker] save error:",u)}}function te(){T||(T=setTimeout(async()=>{T=null,await ee()},Y))}self.onmessage=async u=>{const e=u.data;try{switch(e.type){case"init":{const t=e.rootPubkey||O,s=await Z(t);s?b=s:b.setRoot(t),A({type:"ready",version:z}),A({type:"result",id:e.id,data:{size:b.size()}});break}case"setRoot":{b.setRoot(e.pubkey),x(),A({type:"result",id:e.id,data:!0});break}case"handleEvents":{e.events.length>0&&(b.handleEvent(e.events),te(),x()),A({type:"result",id:e.id,data:e.events.length});break}case"getFollowDistance":{const t=b.getFollowDistance(e.pubkey);A({type:"result",id:e.id,data:t});break}case"isFollowing":{const t=b.isFollowing(e.follower,e.followed);A({type:"result",id:e.id,data:t});break}case"getFollows":{const t=b.getFollowedByUser(e.pubkey);A({type:"result",id:e.id,data:Array.from(t)});break}case"getFollowers":{const t=b.getFollowersByUser(e.pubkey);A({type:"result",id:e.id,data:Array.from(t)});break}case"getFollowedByFriends":{const t=b.followedByFriends(e.pubkey);A({type:"result",id:e.id,data:Array.from(t)});break}case"getSize":{const t=b.size();A({type:"result",id:e.id,data:t});break}case"getUsersByDistance":{const t=b.getUsersByFollowDistance(e.distance);A({type:"result",id:e.id,data:Array.from(t)});break}}}catch(t){A({type:"error",id:e.id,error:t instanceof Error?t.message:String(t)})}}})();
